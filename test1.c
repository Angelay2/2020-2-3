// 联合
// 联合也是一种特殊的自定义类型, 这种类型定义的变量也包含一系列的成员, 
// 特征是这些成员公用一块空间(所以联合也叫共用体)
// 可以分多次使用不同的 但每次只能使用一个
// 共享空间 一共占4个字节 i占4个,c占1个(占的是哪个字节 = 最小地址的那个字节),
// i和c都为第一个, 用谁时谁是第一个
// 联合体变量(i和c)的地址值一样 = 地址最小的那个 
// 联合体内所有成员共享空间 联合体变量及其内部元素的地址数值相同

// 联合应用:
// 可以判断大小端
// 节省空间
// 也可以进行代码级别的类型转换
// (下例1 中un.i为int, un.c 为char,如果再加其他double/short..
// 没有强转,用谁它就是什么类型 不会改变其他成员的类型)
union un{
	char c;
	int i;
};
int main1(){
	union un x;
	printf("%p\n", &x);
	printf("%p\n", &(x.c));
	printf("%p\n", &(x.i));// 三个地址值一样

	system("pause");
	return 0;
}
// x.i 用的是4 个字节
// 赋值为1 => 实质31个0 和一个1 (16进制:01 00 00 00)
// 01为数据的低地址位 低权值的数放在低地址处叫小端
// 若x.c = 0 => 为大端
// 判断大小端
int main2(){
	union un x;
	x.i = 1;
	printf("%d\n", x.c);// 结果为 1

	system("pause");
	return 0;
}

// 联合体的大小至少是最大成员的大小
// 也要考虑内存对齐 只不过只需要考虑我们的联合体是否能整除自身的最大对齐数
// 当最大成员大小不是最大对齐数的整数倍时, 就要对齐到最大对齐数的整数倍
union ux{
	char c[7];
	int i;
};
int main3(){
	printf("%d\n", sizeof(union ux));// 结果为8  
	// 本来开辟空间是7 但是其自身最大对齐数为4 要整除 => 8

	system("pause");
	return 0;
}
